# ES6+ 기초편 1회차

> 코드스피츠77 - ES6+ 기초편 1회차 <https://www.youtube.com/watch?v=0j_eGoF8Q98&list=PLBNdLLaRx_rIF3jAbhliedtfixePs5g2q>

### Why did you do that? 

+ 무엇이 바른 프로그래밍이고 어떻게 짜는 것이 좋은 프로그래밍이라서 내가 이렇게 짰다고 설명할 수 있을까? 부터 생각해야한다. 
+ 지식이란건 흘러가는 것. 지식에 집착하면 붙잡고 있다가 같이 떠내려간다. 다른 언어들이 그랬던 것 처럼 Javascript도 언젠가 다른 무언가로 대체될지 모른다. 
+ 지식과 상관없이 변하지 않는 것은 프로그램의 여러가지 철학이나 방향성이다. 지식이나 언어에 흔들리지 않는 철학적 기반을 정립해야 한다. 
+ 철학: 일관성있게 생각해야하는 변하지 않는 가치관
+ 프로그래밍 체계는 상대주의적인 관전으로 바라봐야한다. 아까는 자식이었지만, 지금은 부모일수도 있다. 
+ 상대주의에는 모두가 동의할 수 있는 기준이 필요하다. 이 기준을 세울 때 합리주의가 동원된다. 
+ 왜 이렇게 프로그래밍했는지 <u>설명</u>하기 위해 필요한 세가지: <u>가치, 원칙, 패턴</u>
+ 가치: 집단, 사회가 공통으로 인식할 수 있는 무언가 가치 있는 것
  + 의사소통: 코드를 보고 의사소통이 잘 된다. > 아무런 설명이 없어도 코드를 보고 팀원이 이해할 수 있다.
  + 단순함: 복잡하면 유지보수가 힘들어서 단순한 구조로 바꿈
  + 유연함: 다얀한 케이스에 적용하기 위해
+ 원칙: 원칙을 정해두면 원칙의 예외를 즉시 알 수 있는 가치가 발생한다. 
  + 지역화: 어떤일을 만들때 전체적으로 영향을 끼치는게 아니라 국지적으로 영향을 끼치게 만들어라(전역변수를 쓰지 말고 지역변수를 써라)
  + 중복제거: 똑같은 로직은 두번 나오게 하지마. 수정, 유지보수가 어려워진다. 
  + 대칭성: 쌍을 맞춰서 Interface를 맞춰라. get이있으면 set이 있고, add가 있으면 remove가 있고
+ 패턴: 선배들의 경험. 절대 진리가 아닌 해봤더니 좋다라는 경험
  + 개발론: 함수지향, 객체지향, 테스트주도 개발 등등
  + 설계론
  + 각종 적용 패턴

### PROGRAM & TIMING

+ | LANGUAGE CODE    | LINT TIME    |
  | ---------------- | ------------ |
  | MACHINE LANGUAGE | COMPILE TIME |
  | FILE             |              |
  | LOAD             |              |
  | RUN              | RUN TIME     |
  | TERMINATE        |              |

  + 코드를 짜고 컴파일해서 파일이 만들어졌으면 로드해서 실행되고 종료되는 흐름
  + Load되어 메모리에 적재된 그것이 프로그램
  + 런타임에 걸리지 않는 논리적인 오류는 context에러. context에러는 기획이 잘못된 경우도 있지만, 개발자끼리 모듈을 나눠서 개발할때 코드 스타일이 달라서 오해가 발생하는 경우도 있다(의사소통 중요)
  + 런타임 에러는 복잡한 상황이 겹쳐서 나오기때문에 재현도 안 되고 잡기도 어렵다. 대부분은 잡을 수 없다. 런타임 에러가 지속적으로 쌓이면 프로그램을 다시 만들어야함. 런타임 에러를 발생시키지 않은 것을 추구해야한다.

+ 스크립트 프로그램

  | LANGUAGE CODE    |                             |
  | ---------------- | --------------------------- |
  | FILE             |                             |
  | LOAD             | 컴파일 없이 브라우저에 로드 |
  | MACHINE LANGUAGE |                             |
  | RUN              |                             |
  | TERMINATE        |                             |

### RUNTIME

+ 메모리에는 적재될때 명령과 데이터 부분으로 나눠서 적재된다. 
+ CPU  
  + 외부버스: 외부 입출력 인터페이스, 명령이 메모리에서 들어올 때 거쳐가는 관문
  +  제어유닛(디코더): 명령을 디코딩한다. 추상적인 명령을 받아서 CPU가 알수있는 명령으로 번역
  + 연산유닛(제어정보) : 연산하여 처리함
  + 데이터 유닛: 메모리의 데이터 부분을 받아온다. 
+ 메모리적재 > CPU로 보냄 > 명령을 제어 유닛으로 가져오기 위해서 외부버스에서 패치 > 디코더에서 디코딩 > 연산 유닛에서 실행할 수 있도록 실행명령을 연산 유닛에 준다. > 연산하기 위해 데이터가 필요하기 때문에 데이터를 데이터 유닛으로 보낸다 > 필요한 값은 연산유닛에게 준다 > 연산결과를 데이터 유닛에게 준다. > 연산결과를 지울지 다시 메모리에 보낼지 여부 명령에 따름
+ 프로그램은 파일을 메로리에 적재해서 순차적으로 실행하고 실행이 다 되면 끝나는 것. 메모리에서 뭔가를 꺼내서 연산한 다음에 다시 메모리에 넣는 것.
+ 진짜 메모리는 로드를 해야지 생기기때문에 컴파일 타이밍에는 진짜 메모리가 없어서 가상메모리 상에서 시뮬레이션해서 검증한다. 컴파일된 파일은 가상메모리에 매핑되어 있기 때문에 로드되면 진짜 메모리에 할당해야한다. (Virtual memory table mapping)
+ 자바스크립트는 컴파일 타임업이 실행되면 무조건 런타임. 컴파일이 없기 때문에 런타임을 레이어로 나눠서 관리한다. 상대적으로 static time이 될 수도 있고, runtime이 될 수도 있다.

### 프로그램이 작동하는 방식

+ 프로그램은 메모리에 적재되기때문에 메모리를 이해하는게 최우선

+ 메모리: 고유한 번호를 주소로 갖는 블록체계. 블록을 나타내는 주소가 몇자리인가는 몇 bit 컴퓨터인지에 따라 다름. 주소가 32bit면 32bit보다 큰 메모리는 가질 수 없다. 주소를 할당할 방법이 없다. 32bit가 가질수있는 최대 메모리 크기는 4G

+ A='TEST', &A=11 (A의 주소는 11), B=&A (A의 주소 11), *B="TEST" (B에 있는 주소의 진짜 값은 TEST)

  어떤 변수는 직접 값을 넣고, 어떤 변수는 주소를 넣고, 주소를 통해서 주소가 가리키는 곳의 값을 얻을 수 있다. 

+ 변수를 공개하면 사용처를 확정할 수 없다. 누가 어떻게 쓸지 모르기때문에 통제할 수 없다. 

+ 참조를 참조(복사)했을 때 문제가 발생한다. 

  해결방법: 함수형: 참조를 쓰지마! 값만써!, 객체지향: 직접 참조하지마! 

+ B={value: &A, V:3} , C=B, D=B

  B.value=&K

  이 경우 value의 값만 바뀔뿐 B,C,D가 가리키는 것은 동일하다. 참조는 직접참조를 쓰지 않고 참조의 참조를 쓴다. (더블 디스패치)

### LEXICAL GRAMMAR

+ 자바스크립트를 구성하는 텍스트요소. 어휘적 측면 문법
+ CONTROL CHARACTER: 제어문자
+ WHITE SPACE: 공백문자
+ LINE TERMINATORS: 개행문자
+ COMMENTS: 코멘트
+ KEYWORD: 예약어
+ LITERALS: 리터럴. 더이상 나눌 수 없는 객체나 값으 표현

### LANGUAGE ELEMENT

+ STATEMENTS 문: 컴파일러 혹은 실행기한테 주는 힌트. 메모리에 흔적이 남지 않는다. 힌트를 받아서 처리한다.
  + 공문(아무것도 없는 것), 식문, 제어문(흐름제어), 선언문(var, const, let: 메모리상에 변수를 할당한다. VTABLE이 함께 작성된다)
+ EXPRESSION 식: 식의 결과는 언제나 값이 된다. 값을 표현하는 여러가지 방법이 식
  + 값 식, 연산식, 호출식
+ IDENTIFIER 식별자: 대부분 변수를 의미한다. 
  + 기본형, 참조형. 

### SYNC FLOW

+ SYNC(동기화 작동) : 메모리가 적제된 명령을 소화하는 동안 간섭할 수 없음. CPU의 동작을 멈출 수 없다. 
+ FLOW CONTROL: 제어문은 흐름을 제어하고 바꿔준다. 
+ SUB FLOW: 함수 클래스를 필요할 때 불러서 사용할 수 있다.