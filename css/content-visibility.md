# content-visibility

- page load performance를 향상 시킬 수 있는 새로운 CSS 프로퍼티
- `content-visibility`는 user agent가 레이아웃과 페인팅을 포함한 요소의 렌더링을 필요할 때까지 스킵 할 수 있도록 해준다.
- 렌더링을 스킵했기 때문에 콘텐츠의 상당 부분이 스크린 밖에 있다면 `content-visibility`를 사용했을 때 초기 사용자 로딩 속도가 더 빨라진다. 또한 화면내 콘테츠와 더 빠르게 상호작용할 수 있다.
- `content-visibility`는 CSS Containment Spec의 기본 요소에 의존한다.

## CSS Containment

- Containment를 사용하면 페이지 하위 트리를 나머지 DOM과 분리할 수 있다. 그러면 브라우저는 이러한 독립적인 부분의 렌더링을 최적화하여 성능을 개선할 수 있다.

## content-visibility로 렌더링 건너뛰기

- 브라우저 최적화는 적절한 세트가 지정된 경우에만 작동할 수 있기 때문에 어떤 containment 값을 사용해야 할지 파악하기 어려울 수 있다.
- `content-visibility`를 사용하면 개발자의 노력은 최소화하면서 브라우저에서 제공하는 최대의 성능 향상을 얻을 수 있다.
- `content-visibility` 속성은 어려 값을 사용할 수 있지만 즉각적인 성능 향상을 제공하는 속성은 `auto` 이다.
- 요소가 화면 밖에 있으면 그 하위 요소는 렌더링되지 않는다. 브라우저는 요소의 내용을 고려하지 않고 요소의 크기를 결정하고 거기서 멈춘다. 요소의 하위 트리의 스타일 및 레이아웃과 같은 대부분의 렌더링은 건너뛴다.
- 요소가 뷰포트에 접근하면 요소의 콘텐츠를 페인팅하고 히트 테스트를 시작한다.
- 주의
  - 브라우저는 건너뛴 하위 트리 중 하나에서 일부 렌더링을 강제로 수행하는 DOM API를 호출하지 않는 경우에만 렌더링 작업을 건너뛸 수 있다.
  - `content-visibility: hidden`이 설정된 요소의 하위 트리에 대해 이러한 API 중 하나를 호출하면 크롬에서 콘솔 메시지를 인쇄한다.

## 접근성에 대한 참고 사항

- `visibility: hidden`과 달리 `content-visibility: auto` 는 document object model과 접근성 트리에서 계속 사용 가능하다.
- 콘텐츠가 로드될 때까지 기다리거나 렌더링 성능에 저하 없이 페이지에서 콘텐츠를 탐색할 수 있다.
- `display: none` 이나 `visibility: hidden` 가 적용된 랜드마크 요소는 뷰포트에 들어갈 때까지 스타일을 렌더링하지 않기 때문에 화면 밖에서 접근성 트리에 표시된다. ⇒ 접근성 트리에 표시되어 잠재적으로 혼란을 야기하는 것을 방지하려면 `aria-hidden="true"` 도 추가해야 한다.
- 주의
  - 크롬 85-89에서는 `content-visiblity: auto` 의 화면 밖에 있는 자식은 보이지 않는 것으로 표시되었다. 특히 제목과 랜드마크 역할은 접근성 도구에 노출되지 않음. ⇒ 크롬 90에서는 이 부분이 노출되도록 업데이트됨

## contain-intrinsic-size를 사용하여 요소의 자연 크기 지정하기

- `content-visiblity` 의 잠재적 이점을 실현하기 위해 브라우저는 콘텐츠의 렌더링 결과가 요소의 크기에 어떤 식으로든 영향을 미치지 않도록 크기 제한을 적용해야 한다.
- 요소는 마치 비어있는 것처럼 레이아웃된다. 요소에 일반 블록 레이아웃에 지정된 높이가 없는 경우 요소의 높이는 0이 된다.
- `contain-intrinsic-size` 를 지정하면 고유 크기 치수의 자식이 하나 있는 것처럼 배치되어 크기가 지정되지 않은 div가 여전히 공간을 차지하도록 한다.
- auto를 지정하면 브라우저는 마지막으로 렌더링 크기를 기억하고 개발자가 제공한 플레이스홀더 크기 대신 해당 크기를 사용한다.

## content-visibility: hidden으로 콘텐츠 숨기기

- 케시된 렌더링 상태의 이점을 활용하면서 콘텐츠가 화면에 표시되는지 여부에 관계없이 렌더링되지 않은 상태로 유지하려면 `content-visibility: hidden` 을 사용한다.
- 요소를 숨기는 다른 일반적인 방법과 비교
  - `display: none` : 요소를 숨기고 렌더링 상태를 파괴한다. 요소를 숨기는 것은 동일한 콘텐츠로 새 요소를 렌더링하는 것만큼 비용이 많이 든다.
  - `visiblisity: hidden` : 요소를 숨기고 렌더링 상태를 유지한다. 요소와 하위 트리는 여전히 페이지에서 공간을 차지하며 계속 클릭할 수 있다. 문서에서 요소가 실제로 제거되지 않는다. 숨겨져 있어도 필요할 때마다 렌더링 상태를 업데이트한다.
- `content-visibility: hidden` 은 렌더링 상태를 유지하면서 요소를 숨긴다. 필요한 경우 요소가 다시 표시될 때만 변경이 이루어진다.

## 다음 페인트에 대한 상호작용(INP)에 미치는 영향

- INP는 사용자 입력에 안정적으로 반응하는 페이지의 기능을 평가하는 지표이다.
- 응답성은 렌더링 작업을 포함하여 메인 스레드에서 발생하는 과도한 작업량에 의해 영향을 받을 수 있다.
- 특정 페이지에서 렌더링 작업을 줄일 수 있다면 메인 스레드가 사용자 입력에 더 빨리 응답할 수 있는 기회를 제공한다.
- `content-visibility` 속성을 적절히 사용하여 화면 밖 요소의 레이아웃 및 렌더링을 지연시키도록 하면 메인 스레드가 사용자에게 표시되는 중요한 작업에 응답할 수 있는 기회를 얻게 된다. 일부 상황에서 INP가 향상될 수 있다.

https://web.dev/articles/content-visibility

https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment
