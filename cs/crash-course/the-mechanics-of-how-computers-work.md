## 컴퓨터의 작동 원리

### 1. 초기 컴퓨팅

**주판**

- 계산을 위해 가장 예전부터 사용된 장비
- 기원 전 2500년에 메소포타미아에서 발명
- 컴퓨터 하드디스크에 숫자를 저장하는 것과 같이 현재 계산 상태를 기록한다

**컴퓨터라는 단어의 등장**

+ 1613년 Richard Braithwait가 집필한 책에 등장
+ 기계가 아닌 직업을 의미, 가끔씩 기계의 도움으로 계산을 할 수 있는 사람을 일컬음
+ 1800년대에 직업이 아닌 기계로 의미가 전환

**Stepped reckoner**

- 1694년 독일의 정치가 Gottfried Leibniz가 개발
- 사칙 연산을 할 수 있는 최초의 장치
- 하나의 결과를 얻기 위해서 몇 시간, 며칠이나 시간이 걸렸고 비싸서 대부분의 사람들은 구하기 어려웠다

**Precomputed tables**

- 특정한 계산에 대해 미리 값을 구해서 표로 정리해 놓은 것
- 제곱근을 구하고 싶으면 Stepped reckoner로 몇시간 걸려서 구하는 게 아니라 제급곤 표로 가득한 거대한 책을 통해 찾음
- Range tables: 전쟁시 사격수에게 사격이 가능한 환경 조건과 거리를 찾을 수 있게 도와줌. 캐논의 각도도 알려줌, 캐논이나 포탄의 설계가 변경되면 새로운 계산표가 필요했다. > 시간이 걸리고 오류도 발생

**차분기관 (Diffrence Engine)**

+ Charles Babbage가 제안한 새로운 기계 장치
+ 다항식을 계산할 수 있는 기계
+ 다항식은 여러 변수간의 관계를 설명할 수 있다. 대수나 삼각 함수를 측정하는 데에도 사용 가능하다
+ 1820년부터 20년동안 연구했지만 프로젝트는 무산됨
+ 1991년에 개발 성공

**분석 엔진 (Analytical Engine)**

- Charles Babbage가 차분기관을 연구하는 동안 생각해 낸 것
- 단순히 하나의 계산에 국한되지 않고 범용적으로 사용가능 한 컴퓨터
- 데이터를 받을 수 있고, 순차적으로 작동 가능, 기억장치와 원시적인 프린터도 있음
- 완성되지는 못 했지만 이 아이디어는 자동화된 작업, 컴퓨터 프로그램으로 나아갈 수 있는 가이드 역할을 해주었다.

**세계 최초의 프로그래머**

- 영국인 수학자 Ada Lovelace
- Analytical Engine에 대한 가상 프로그램을 기록함
- "미래에는 분석을 위한 새롭고, 다양하고 강력한 언어가 개발될 것이다."

**Tabulating machine**

- 1890년 미국 정부가 인구조사를 위해 Herman Hollerith에게 연구를 맡김
- 전통적인 계산 시스템을 사용하여 수를 저장하는 것에 전동 장치를 결합
- 격자무늬가 있는 펀치 카드를 사용하였고 펀치를 뚫으면 데이터를 나타낼 수 있다. 
- 카드를 기계에 넣었을 때 작은 금속핀이 카드를 향해 내려고오고 구멍이 뚫려있다면  핀은 종이에 있는 구멍을 통과한다. 회로가 완성되면 종이는 유리병속으로 들어간다. 완성된 회로는 전기 모터를 움직이고 기어를 돌려 계산을 한다.
- Herman Hollerith는 The Tabulating machine Company를 설립하였고 1924년 다른 기계 제작사와 합병된다 > IBM

### 2. 전자 컴퓨팅

**Havard Mark I**

- 가장 크기가 큰 전기식 기계 컴퓨터들 중 하나
- 2차 세계 대전 중 IBM이 동맹군을 위해 1944년에 개발
- 76만 5천개의 부품들로 구성되었고 3백만개의 연결 그리고 500만일의 전선으로 구성됨
- 초기 용도는 맨하탄 프로젝트에 대한 시뮬레이션을 실행하는 것

**Mechanical Relay**

- 계전기: 전류의 유무에 따라 회로를 여닫는 장치
- 제어선은 연결 안쪽의 내부 코일선과 연결됨 전류가 코일로 흐를 때 전자기장이 만들어지고 차례로 금속 부분이 릴레이 안쪽으로 들어오면서 금속 기계팔을 끌어 당겨 회로를 닫는다.
- 계전기 안에 있는 기계식 팔은 무거워서 열린 상태와 닫힌 상태에서 즉시 이동할 수 없었다
- 1940년대 성능이 좋은 계전기는 1초에 50번 움직일 수 있었음 > 방대하고 복잡한 문제 해결에는 불충분
- Havard Mark II의 계산 속도는 덧셈, 뺄셈 1초당 3개, 곱셈 6초, 나눗셈 15초. 삼각함수 같은 더 복잡한 계산은 1분 넘게 걸림
- 계전기의 한계: 느린 속도와 마모
- 계전기의 숫자가 늘어나면 실패 확률도 증가하는데 Havard Mark I는 약 3500개의 계전 장치를 가지고 있었다.

**열 이온 밸브 (Thermionic valve)**

- 영국 물리학자 John Amborse Fleming이 개발한 새로운 전기 구성 요소
- 밀폐된 유리 전구 안에 두개의 전극을 가둔 것
- 최초의 진공관
- 하나의 전극이 가열되면 전자를 방출(연 이온 방출)하고 다른 다른 전극은 이 전자를 끌어 당길 수 있다. 
- 전기의 흐름을 만들지만 양극으로 충전된 상태에서만 진행됨
- 음극이거나 중성 전하를 띠게 되면 전자는 더이상 진공을 통해 끌어당기지 않는다. 전류가 흐르지 않음

**3극 진공관**

- 플레밍이 고안해낸 두 개의 전극 사이에 세번째 제어 전극을 추가한 것
- 제어 전극에 양전하를 더하면서 이전과 같이 전류가 흐를 수 있도록 하고 제어 전극에 음전하가 주어지면 전자의 흐름을 막는다. 제어선을 조작하면서 회로를 열거나 닫을 수 있다
- 거의 계전기 같지만 진공관은 움직이는 부분이 없기 때문에 마모가 적고 1초에 수천번을 전환할 수 있다.
- 단점: 부서지기 쉽고, 전구처럼 고장남
- 1940년대 진공관의 비용과 신뢰성은 상당히 나아져 실현이 가능했음. 정부나 재력을 지닌 사람들은 컴퓨터에 진공관을 사용할만 해졌음
- 전자 기계식 컴퓨팅에서 전자식 컴퓨팅으로의 전환을 의미한다

**colossus mk 1**

- 최초로 진공관이 큰 뮤모의 컴퓨팅에 사용됨. 1943년 12월 Tommy Flowers라는 기술자가 개발했다. 나치 통신을 해독함
- 클로서스의 최초 버전은 1600개의 진공관을 가지고있었고 코드를 해독하기 위해 총 열 개의 clossi가 만들어짐
- 클로서스는 최초의 프로그래밍이 가능한 전자 컴퓨터로 여겨진다
- 프로그래밍은 일종으 플러그 보드에 수백개의 선을 꽂으면서 진행됨. 올바른 작업을 수행하도록 컴퓨터를 설정하기 위해 필요했다
- 프로그래밍이 가능하면서도 특정한 계산을 수행할 수 있도록 구성되어야 했다. 

**ENIAC**

- 1946년 펜실베니아 대학에서 완성
- 세계 최초의 진정한 범용으로 프로그래밍이 가능한 전자식 컴퓨터
- 초당 5000자리 숫자의 덧셈과 뺄셈이 가능하다
- 진광관문제로 애니악은 일반적으로 한 번에 약 반나절 동안 작동이 중지됨

**컴퓨팅의 새로운 시대**

- 1950년대에는 진공관으로 설계된 컴퓨팅조차 한계에 다다랐음
- 속도와 안정성을 개선하고 가격과 크기를 줄이기 위해 급진적인 전자 스위치가 필요했다
- 1947년에 벨 연구소 과학자 John Bardeen, Walter Brattain, William Shokley가 트랜지스터를 발명했다.

**트렌지스터**

- 트렌지스터는 두 개의 전극이 있고 반도체로 분리되어 있는데 제어선이 게이트 전극에 닿아 게이트의 전하를 변화시키면 반도체 물질의 전도도가 조작되어 전류를 흐르게 하거나 멈출 수 있다.

- 트렌지스터는 속도도 빠르고 깨지기 쉬운 진공관과 달리 고체 상태의 고형물질로 만들어져 있음. 또한 계전기나 진공관보다 더 작게 만들 수 있음 > 훨씬 더 작고 저렴한 컴퓨터 만들기 가능


### 3. 부울연산과 논리게이트

**이진**

- 2가지 전기적 상태만으로 중요한 정보를 표시
- 컴퓨터 안에서 on 상태는 전류가 흐르고 true를 나타내는 상태. off 상태는 전기가 흐르지 않고 false상태를 나타낸다
- true와 false를 이진수 1과 0으로 표현

**NOT**

+ 참이든 거짓이든 하나의 값을 취하고 그것을 부정함

+ | INPUT | OUTPUT |
  | ----- | ------ |
  | TRUE  | FALSE  |
  | FALSE | TRUE   |

**AND**

+ 모든 입력이 참일 경우에만 참

+ | INPUT A | INPUT B | OUTPUT |
  | ------- | ------- | ------ |
  | TRUE    | TRUE    | TRUE   |
  | TRUE    | FALSE   | FALSE  |
  | FALSE   | TRUE    | FALSE  |
  | FALSE   | TRUE    | FALSE  |

**OR**

+ 하나의 입력만 참이어도 출력이 참이 되는 연산

+ | INPUT A | INPUT B | OUTPUT |
  | ------- | ------- | ------ |
  | TRUE    | TRUE    | TRUE   |
  | TRUE    | FALSE   | TRUE   |
  | FALSE   | TRUE    | TRUE   |
  | FALSE   | FALSE   | FALSE  |

**XOR**

+ OR연산과 비슷한데 모든 입력이 참이면 출력이 거짓이라는 차이가 있음

+ | INPUT A | INPUT B | OUTPUT |
  | ------- | ------- | ------ |
  | TRUE    | TRUE    | FALSE  |
  | TRUE    | FALSE   | TRUE   |
  | FALSE   | TRUE    | TRUE   |
  | FALSE   | FALSE   | FALSE  |

### 4. 이진수 숫자와 문자 나타내기

**이진수**

+ 1과 0만 사용

+ 하나의 자릿수가 오른쪽에 있는 수보다 2배 더 큼

+ 예) 10110111 = 128 + 32 + 16 + 4 + 2 + 1 = 183

  | 1    | 0    | 1    | 1    | 0    | 1    | 1    | 1    |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | 128  | 64   | 32   | 16   | 8    | 4    | 2    | 1    |

+ 이진수에서 0과 1을 각각 비트라고 부른다

+ 8비트는 1바이트

**양수와 음수**

+ 대부분의 컴퓨터는 첫번째 비트에서 1은 음의 값, 0은 양의 값을나타내는 신호로 사용한다
+ 나머지 비트들은 그 숫자 자체를 나타낸다
+ 32비트는 ±20억을 나타낼 수 있다. 64비트로 나타낼 수 있는 가장 큰 숫자는 920경

**부동 소수점**

+ 625.9 를 0.6259 * 10^3 으로 표시할 때 6259는 유효숫자, 3은 지수
+ 32비트 부동 소수점 표기
  + 첫번째 비트: 양수/음수
  + 다음 8비트: 지수 저장
  + 나머지 23비트: 유효숫자를 나타냄

**문자 표시**

+ 컴퓨터는 문자를 나타낼 때 단순히 숫자를 사용한다. 문자들에 번호를 매기는 방법!

+ ASCII
  + 1963년에 발명됨
  + 7비트의 코드, 128개의 다른 값을 저장할 수 있음
  + 대문자, 소문자, 0~9, @기호나 구두점 같은 상징적인 것도 인코딩 가능
  + 초기의 표준이었기 때문에 널리 사용되었고 다른 회사에서 만든 여러 컴퓨터와 데이터를 교환하는데 사용되었다.
  + 한계점: 영어를 위해서만 설계되었기 때문에 각각의 나라에서 다양한 바이트의 인코딩 구조를 개발했으며 이들은 서로 호환되지 않음.
+ 유니코드
  + 1992년에 제정. 각각의 국제적인 제도를 없애고 하나의 보편적인 인코딩 구조로 대체함
  + 유니코드의 일반적인 버전은 16비트 공간을 사용해서 백만개 넘는 코드를 넣음